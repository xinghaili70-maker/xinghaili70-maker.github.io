<!doctype html>
<html lang="zh-CN">

	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>VR 看房导航（单文件示例）</title>
		<!-- 直接在HTML中引入Three.js，而不是动态加载 -->
		<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
		<style>
			html,
			body {
				height: 100%;
				margin: 0;
				font-family: system-ui, Segoe UI, Roboto, 'Helvetica Neue', Arial
			}

			#app {
				height: 100%;
				display: grid;
				grid-template-rows: 1fr auto
			}

			#canvas-container {
				position: relative;
				background: #000
			}

			canvas {
				display: block;
				width: 100%;
				height: 100%
			}

			.ui {
				position: absolute;
				left: 12px;
				top: 12px;
				z-index: 10;
				display: flex;
				flex-direction: column;
				gap: 8px
			}

			.controls {
				position: absolute;
				right: 12px;
				top: 12px;
				z-index: 10;
				display: flex;
				flex-direction: column;
				gap: 8px;
				align-items: flex-end
			}

			button {
				background: rgba(255, 255, 255, 0.9);
				border: 0;
				padding: 8px 12px;
				border-radius: 8px;
				cursor: pointer
			}

			.thumbs {
				position: absolute;
				left: 12px;
				bottom: 12px;
				z-index: 10;
				display: flex;
				gap: 8px;
				align-items: center
			}

			.thumb {
				width: 90px;
				height: 56px;
				object-fit: cover;
				border-radius: 6px;
				cursor: pointer;
				border: 2px solid rgba(255, 255, 255, 0.15)
			}

			.thumb.active {
				border-color: #3b82f6
			}

			footer {
				background: #fafafa;
				padding: 8px 12px;
				border-top: 1px solid #eee;
				display: flex;
				gap: 12px;
				align-items: center
			}

			input[type=file] {
				display: none
			}

			.label {
				background: #fff;
				padding: 8px 12px;
				border-radius: 8px;
				border: 1px dashed #ddd;
				cursor: pointer
			}

			.hint {
				font-size: 12px;
				color: #666
			}

			#loading {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				background: rgba(0, 0, 0, 0.7);
				color: white;
				padding: 10px 20px;
				border-radius: 5px;
				z-index: 100
			}

			/* 热点相关样式 */
			.hotspot {
				position: absolute;
				width: 50px;
				height: 50px;
				cursor: pointer;
				transform: translate(-50%, -50%);
				z-index: 5;
			}

			.hotspot::before {
				content: '→';
				display: flex;
				align-items: center;
				justify-content: center;
				width: 100%;
				height: 100%;
				background: rgba(59, 130, 246, 0.9);
				color: white;
				font-size: 24px;
				border-radius: 50%;
				box-shadow: 0 0 15px rgba(59, 130, 246, 0.8);
				animation: pulse 2s infinite;
				transition: transform 0.3s ease;
			}

			.hotspot:hover::before {
				transform: scale(1.1);
			}

			.hotspot-label {
				position: absolute;
				top: 55px;
				left: 50%;
				transform: translateX(-50%);
				background: rgba(0, 0, 0, 0.8);
				color: white;
				padding: 4px 8px;
				border-radius: 4px;
				font-size: 12px;
				white-space: nowrap;
				z-index: 5;
			}

			@keyframes pulse {
				0% {
					box-shadow: 0 0 15px rgba(59, 130, 246, 0.8);
				}

				50% {
					box-shadow: 0 0 25px rgba(59, 130, 246, 1);
				}

				100% {
					box-shadow: 0 0 15px rgba(59, 130, 246, 0.8);
				}
			}
		</style>
	</head>

	<body>
		<div id="app">
			<div id="canvas-container">
				<!-- Three.js canvas will be appended here -->
				<div id="loading">加载中...</div>
				<div class="ui">
					<button id="prevRoom">◀ 上一房间</button>
					<button id="nextRoom">下一房间 ▶</button>
					<label class="label" id="addLabel">+ 添加房间（上传全景图片）
						<input id="fileInput" type="file" accept="image/*">
					</label>
					<div class="hint">说明：建议上传 2:1 或更宽的 equirectangular 全景图（例如 4096×2048）。</div>
				</div>
				<div class="controls">
					<button id="toggleAuto">自动旋转：关</button>
					<button id="resetView">重置视角</button>
				</div>
				<div class="thumbs" id="thumbs"></div>
				<!-- 热点将动态添加到这里 -->
				<div id="hotspots-container"
					style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
			</div>
			<footer>
				<div>VR 看房导航示例 — 支持旋转、缩放（滚轮/捏合）、点击热点切换房间</div>
				<div style="margin-left:auto;font-size:12px;color:#666">键盘：← → 切换房间，空格切换自动旋转</div>
			</footer>
		</div>

		<script>
			// 基本变量
			const container = document.getElementById('canvas-container');
			const thumbsEl = document.getElementById('thumbs');
			const loadingEl = document.getElementById('loading');
			const hotspotsContainer = document.getElementById('hotspots-container');
			let scene, camera, renderer, controls, sphereMesh;
			let rooms = []; // {name, url, thumb, connections: [{targetRoom, yaw, pitch, description}]}
			let current = 0;
			let autoRotate = false;
			let hotspots = []; // 存储当前场景中的热点元素

			// 页面加载完成后初始化
			window.onload = function() {
				console.log('页面加载完成，开始初始化Three.js');
				try {
					init();
					animate();
					console.log('初始化完成');
				} catch (error) {
					console.error('初始化失败:', error);
					alert('初始化失败，请检查浏览器控制台');
				}
			};

			function init() {
				// 1、创建空场景用于添加其他内容
				scene = new THREE.Scene();

				// 2、创建并配置一个透视相机（模拟人眼），并使其自适应容器尺寸
				const width = container.clientWidth;
				const height = container.clientHeight;
				// PerspectiveCamera(垂直方向上视野角度不能超过180°, 长宽比保证图片不被拉伸, 近平面（距离多近就可以渲染了）, 远平面（距离多远停止渲染）)
				camera = new THREE.PerspectiveCamera(100, width / height, 0.1, 2000);
				// 设置相机水平垂直方向居中 向前移动0.1单位
				camera.position.set(0, 0, 0.1);

				// 3、创建渲染器
				renderer = new THREE.WebGLRenderer({
					antialias: true
				});
				renderer.setSize(width, height);
				renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
				container.appendChild(renderer.domElement);

				// 4、创建几何形状（球体）  SphereGeometry(半径，绕水平方向可得分割数，绕垂直方向可得分割数)
				const geometry = new THREE.SphereGeometry(500, 60, 40);
				// 5、创建材质
				const material = new THREE.MeshBasicMaterial({
					color: 0x000000,
					side: THREE.BackSide
				});
				// 6、创建网格将球体和材质结合
				sphereMesh = new THREE.Mesh(geometry, material);
				// 7、场景中添加网格
				scene.add(sphereMesh);

				// 添加控制器 实现可拖拽旋转视角、缩放等
				controls = new THREE.OrbitControls(camera, renderer.domElement);
				controls.enablePan = false;
				controls.enableZoom = true;
				controls.zoomSpeed = 1.0;
				controls.rotateSpeed = 0.4;
				controls.minDistance = 0.1;
				controls.maxDistance = 1000;
				controls.enableDamping = true;
				controls.dampingFactor = 0.05;
				controls.maxPolarAngle = Math.PI - 0.1;
				controls.minPolarAngle = 0.1;

				// 事件监听
				window.addEventListener('resize', onWindowResize);
				renderer.domElement.addEventListener('wheel', onWheel, {
					passive: false
				});
				renderer.domElement.addEventListener('touchmove', onTouchMove, {
					passive: false
				});

				// 按钮事件
				document.getElementById('prevRoom').addEventListener('click', () => {
					if (rooms.length > 0) {
						switchRoom((current - 1 + rooms.length) % rooms.length);
					}
				});

				document.getElementById('nextRoom').addEventListener('click', () => {
					if (rooms.length > 0) {
						switchRoom((current + 1) % rooms.length);
					}
				});

				document.getElementById('toggleAuto').addEventListener('click', toggleAuto);
				document.getElementById('resetView').addEventListener('click', resetView);
				document.getElementById('fileInput').addEventListener('change', handleFiles);

				// 键盘控制
				window.addEventListener('keydown', (e) => {
					if (e.code === 'ArrowRight') document.getElementById('nextRoom').click();
					if (e.code === 'ArrowLeft') document.getElementById('prevRoom').click();
					if (e.code === 'Space') toggleAuto();
				});

				// 添加示例房间
				addSampleRooms();

				// 隐藏加载提示
				setTimeout(() => {
					if (loadingEl) loadingEl.style.display = 'none';
				}, 500);
			}

			// 创建示例房间，添加连接信息
			function addSampleRooms() {
				console.log('添加示例房间');
				// 定义房间连接 Math.PI 弧度180°   以当前视口为基准，顺时针为正方向，逆时针为负方向。
				const livingRoomConnections = [{
						targetRoom: 1,
						yaw: -Math.PI / 2,
						pitch: 0,
						description: "卧室"
					}, // 右侧
					{
						targetRoom: 2,
						yaw: Math.PI,
						pitch: 0,
						description: "阳台"
					} // 左侧
				];

				const bedroomConnections = [{
						targetRoom: 0,
						yaw: -350,
						pitch: 0,
						description: "客厅"
					} // 左侧
				];

				const balcony = [{
						targetRoom: 0,
						yaw: -Math.PI / 2,
						pitch: 0,
						description: "客厅"
					}, // 右侧

				];
				// 图片预加载函数
				function loadImage(url) {
					return new Promise((resolve, reject) => {
						const img = new Image();
						img.onload = () => resolve(url);
						img.onerror = reject;
						img.src = url;
					});
				}
				// 为每个房间生成缩略图
				function createThumbnail(url, name) {
					// 这里你可以选择使用原图片作为缩略图，或者创建一个简单的颜色块
					// 简单方案：使用原图片作为缩略图
					return url;

					// 或者使用颜色块作为缩略图（类似原来的方式）
					// return makeCanvas('#6b7280', name);
				}
				// 使用本地图片添加房间
				Promise.all([
					loadImage('/vr/img/living.png'),
					loadImage('/vr/img/bedroom.png'),
					loadImage('/vr/img/yt.png'),
					loadImage('/vr/img/sw.png')
				]).then(([livingRoomImg, bedroomImg, balconyImg]) => {
					// 添加三个示例房间，使用本地图片
					rooms.push({
						name: '客厅',
						url: livingRoomImg,
						thumb: createThumbnail(livingRoomImg, '客厅'),
						connections: livingRoomConnections
					});

					rooms.push({
						name: '卧室',
						url: bedroomImg,
						thumb: createThumbnail(bedroomImg, '卧室'),
						connections: bedroomConnections
					});

					rooms.push({
						name: '厨房',
						url: balconyImg,
						thumb: createThumbnail(balconyImg, '阳台'),
						connections: balcony
					});

					// 渲染缩略图并加载第一个房间
					renderThumbs();
					if (rooms.length > 0) {
						switchRoom(0);
					}
				}).catch(error => {
					console.error('加载本地图片失败:', error);
					alert('加载图片失败，请检查图片路径是否正确');
					// 回退到使用canvas生成的图片
					fallbackToCanvasRooms();
				});
			}
			// 回退方案：当本地图片加载失败时使用canvas生成图片
			function fallbackToCanvasRooms() {
				console.log('回退到使用Canvas生成的图片');
				// 简化的makeCanvas函数，确保兼容性
				function makeCanvas(color, label, connections) {
					try {
						const c = document.createElement('canvas');
						c.width = 1024;
						c.height = 512; // 2:1比例
						const ctx = c.getContext('2d');

						// 绘制背景
						ctx.fillStyle = color;
						ctx.fillRect(0, 0, c.width, c.height);

						// 绘制文字
						ctx.fillStyle = 'rgba(255,255,255,0.8)';
						ctx.font = 'bold 40px Arial';
						ctx.textAlign = 'center';
						ctx.fillText(label, c.width / 2, c.height / 2);

						// 添加简单的方向指示文本
						if (connections) {
							ctx.font = '16px Arial';
							connections.forEach(conn => {
								let x, y;

								// 根据yaw和pitch确定文本位置（简化版）
								if (conn.yaw < 0) {
									x = 100; // 左侧
								} else {
									x = c.width - 100; // 右侧
								}

								// y位置基于pitch（简化）
								y = c.height / 2 - conn.pitch * 100;

								// 绘制方向指示
								ctx.fillStyle = 'rgba(255,255,255,0.9)';
								ctx.textAlign = conn.yaw < 0 ? 'left' : 'right';
								ctx.fillText(conn.description || `前往${conn.targetRoom}`, x, y);

								// 绘制箭头
								ctx.fillStyle = '#3b82f6';
								ctx.beginPath();
								if (conn.yaw < 0) {
									ctx.moveTo(x, y);
									ctx.lineTo(x + 20, y - 5);
									ctx.lineTo(x + 20, y + 5);
								} else {
									ctx.moveTo(x, y);
									ctx.lineTo(x - 20, y - 5);
									ctx.lineTo(x - 20, y + 5);
								}
								ctx.closePath();
								ctx.fill();
							});
						}

						return c.toDataURL('image/png');
					} catch (e) {
						console.error('创建画布失败:', e);
						// 返回简单的纯色图片作为备份
						return `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="1024" height="512" style="background:${color}"><text x="512" y="256" font-family="Arial" font-size="40" fill="rgba(255,255,255,0.8)" text-anchor="middle">${label}</text></svg>`;
					}
				}



				// 添加三个示例房间，包含连接信息
				rooms.push({
					name: '客厅',
					url: makeCanvas('#6b7280', '客厅', livingRoomConnections),
					thumb: makeCanvas('#6b7280', '客厅'),
					connections: livingRoomConnections
				});

				rooms.push({
					name: '卧室',
					url: makeCanvas('#0ea5a4', '卧室', bedroomConnections),
					thumb: makeCanvas('#0ea5a4', '卧室'),
					connections: bedroomConnections
				});

				rooms.push({
					name: '厨房',
					url: makeCanvas('#f97316', '厨房', balcony),
					thumb: makeCanvas('#f97316', '厨房'),
					connections: balcony
				});

				// 渲染缩略图并加载第一个房间
				renderThumbs();
				if (rooms.length > 0) {
					switchRoom(0);
				}
			}

			// 渲染缩略图
			function renderThumbs() {
				console.log('渲染缩略图，房间数量:', rooms.length);
				thumbsEl.innerHTML = '';

				rooms.forEach((r, idx) => {
					const img = document.createElement('img');
					img.src = r.thumb;
					img.className = 'thumb' + (idx === current ? ' active' : '');
					img.title = r.name;
					img.addEventListener('click', () => switchRoom(idx));
					thumbsEl.appendChild(img);
				});
			}

			// 创建热点标记
			function createHotspots() {
				// 清除之前的热点
				clearHotspots();

				const room = rooms[current];
				if (!room || !room.connections) return;

				// 为每个连接创建热点
				room.connections.forEach((conn, index) => {
					// 创建热点元素
					const hotspotEl = document.createElement('div');
					hotspotEl.className = 'hotspot';
					hotspotEl.style.pointerEvents = 'auto'; // 确保可以点击

					// 创建标签元素
					const labelEl = document.createElement('div');
					labelEl.className = 'hotspot-label';

					// 查找目标房间名称
					const targetRoom = rooms[conn.targetRoom];
					if (targetRoom) {
						labelEl.textContent = conn.description || targetRoom.name;
					} else {
						labelEl.textContent = '未知房间';
					}

					// 点击事件 - 切换到目标房间
					hotspotEl.addEventListener('click', (e) => {
						e.stopPropagation();
						switchRoom(conn.targetRoom);
					});

					// 添加到容器
					hotspotsContainer.appendChild(hotspotEl);
					hotspotsContainer.appendChild(labelEl);

					// 保存引用
					hotspots.push({
						hotspot: hotspotEl,
						label: labelEl,
						yaw: conn.yaw,
						pitch: conn.pitch
					});
				});

				// 初始更新热点位置
				updateHotspots();

				// 当视角变化时更新热点位置
				controls.addEventListener('change', updateHotspots);
			}

			// 更新热点位置
			function updateHotspots() {
				hotspots.forEach(item => {
					const {
						hotspot,
						label,
						yaw,
						pitch
					} = item;

					// 计算热点在球面上的位置
					const x = Math.cos(pitch) * Math.sin(yaw);
					const y = Math.sin(pitch);
					const z = Math.cos(pitch) * Math.cos(yaw);

					// 创建向量
					const hotspotVector = new THREE.Vector3(x, y, z).multiplyScalar(500); // 500是球体半径

					// 将3D位置转换为屏幕坐标
					const screenPosition = hotspotVector.project(camera);

					// 计算DOM位置
					const domPositionX = ((screenPosition.x * 0.5) + 0.5) * container.clientWidth;
					const domPositionY = (-(screenPosition.y * 0.5) + 0.5) * container.clientHeight;

					// 检查热点是否在相机前面
					const isVisible = screenPosition.z <= 1;

					// 更新热点样式
					hotspot.style.display = isVisible ? 'block' : 'none';
					label.style.display = isVisible ? 'block' : 'none';

					if (isVisible) {
						hotspot.style.left = `${domPositionX}px`;
						hotspot.style.top = `${domPositionY}px`;
						label.style.left = `${domPositionX}px`;
						label.style.top = `${domPositionY}px`;

						// 根据角度调整箭头方向
						let rotation = 0;
						if (yaw > Math.PI / 4) {
							rotation = 180; // 右侧
						} else if (yaw < -Math.PI / 4) {
							rotation = 0; // 左侧
						} else if (yaw > 0) {
							rotation = 90; // 上方
						} else {
							rotation = -90; // 下方
						}

						hotspot.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
					}
				});
			}

			// 清除热点
			function clearHotspots() {
				// 移除所有热点元素
				hotspots.forEach(item => {
					if (item.hotspot.parentNode) {
						item.hotspot.parentNode.removeChild(item.hotspot);
					}
					if (item.label.parentNode) {
						item.label.parentNode.removeChild(item.label);
					}
				});

				// 清空热点数组
				hotspots = [];
			}

			// 切换房间
			function switchRoom(index) {
				console.log('切换到房间:', index);
				if (rooms.length === 0 || index < 0 || index >= rooms.length) return;

				// 移除之前的change事件监听器，避免重复绑定
				controls.removeEventListener('change', updateHotspots);

				current = index;

				// 更新缩略图高亮
				Array.from(thumbsEl.children).forEach((el, i) => {
					el.classList.toggle('active', i === current);
				});

				const room = rooms[current];
				console.log('加载房间:', room.name);
				// 重置相机视角到中心 - 添加这一行
				resetView();
				// 加载新房间全景图
				loadEquirect(room.url, () => {
					// 加载完成后创建热点
					createHotspots();
				});
			}

			// 加载全景图
			function loadEquirect(url, onLoad) {
				console.log('加载全景图:', url.substring(0, 50) + '...');

				const loader = new THREE.TextureLoader();
				const old = sphereMesh.material;

				loader.load(url,
					(tex) => {
						console.log('纹理加载成功');
						try {
							tex.minFilter = THREE.LinearFilter;
							tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
							const mat = new THREE.MeshBasicMaterial({
								map: tex,
								side: THREE.BackSide
							});
							sphereMesh.material = mat;

							// 释放旧资源
							if (old && old.map) old.map.dispose();
							if (old) old.dispose();

							// 加载完成回调
							if (typeof onLoad === 'function') {
								onLoad();
							}
						} catch (e) {
							console.error('应用纹理失败:', e);
						}
					},
					(xhr) => {
						if (xhr.lengthComputable) {
							const percent = Math.round((xhr.loaded / xhr.total) * 100);
							console.log(`加载进度: ${percent}%`);
						}
					},
					(err) => {
						console.error('加载全景失败:', err);
					}
				);
			}

			// 处理文件上传
			function handleFiles(e) {
				console.log('处理文件上传');
				const files = e.target.files;
				if (!files || files.length === 0) return;

				for (const f of files) {
					// 检查文件类型
					if (!f.type.match('image.*')) {
						console.warn('非图片文件:', f.name);
						continue;
					}

					console.log('处理图片文件:', f.name);
					const reader = new FileReader();

					reader.onload = (evt) => {
						try {
							const data = evt.target.result;
							console.log('文件读取成功:', data.substring(0, 50) + '...');

							// 为上传的房间创建默认连接
							const newRoomIndex = rooms.length;
							// 默认与最后一个房间相连
							const defaultConnections = [];
							if (rooms.length > 0) {
								defaultConnections.push({
									targetRoom: rooms.length - 1,
									yaw: -Math.PI / 2, // 左侧
									pitch: 0,
									description: rooms[rooms.length - 1].name
								});
							}

							// 添加到房间列表
							rooms.push({
								name: f.name,
								url: data,
								thumb: data,
								connections: defaultConnections
							});

							// 更新之前的房间连接，使其也能连接到新房间
							if (rooms.length > 1) {
								rooms[rooms.length - 2].connections.push({
									targetRoom: newRoomIndex,
									yaw: Math.PI / 2, // 右侧
									pitch: 0,
									description: f.name
								});
							}

							renderThumbs();
							switchRoom(rooms.length - 1);
						} catch (err) {
							console.error('处理图片失败:', err);
						}
					};

					reader.onerror = () => {
						console.error('文件读取失败:', f.name);
					};

					reader.readAsDataURL(f);
				}

				// 清空文件输入
				e.target.value = '';
			}

			// 自动旋转控制
			function toggleAuto() {
				autoRotate = !autoRotate;
				document.getElementById('toggleAuto').textContent = `自动旋转：${autoRotate ? '开' : '关'}`;
			}

			// 重置视角
			function resetView() {
				// 重置控制器状态
				controls.reset();
				// 设置相机的视场角
				camera.fov = 75;
				// 更新相机的投影矩阵
				camera.updateProjectionMatrix();
			}

			// 窗口大小变化
			function onWindowResize() {
				const w = container.clientWidth;
				const h = container.clientHeight;
				camera.aspect = w / h;
				camera.updateProjectionMatrix();
				renderer.setSize(w, h);

				// 更新热点位置
				updateHotspots();
			}

			// 鼠标滚轮缩放
			function onWheel(e) {
				e.preventDefault();
				const delta = Math.sign(e.deltaY);
				camera.fov = THREE.MathUtils.clamp(camera.fov + delta * 2, 30, 100);
				camera.updateProjectionMatrix();
			}

			// 触摸缩放
			let lastTouchDist = null;

			function onTouchMove(e) {
				if (e.touches && e.touches.length === 2) {
					const dx = e.touches[0].clientX - e.touches[1].clientX;
					const dy = e.touches[0].clientY - e.touches[1].clientY;
					const dist = Math.hypot(dx, dy);

					if (lastTouchDist) {
						const diff = dist - lastTouchDist;
						camera.fov = THREE.MathUtils.clamp(camera.fov - diff * 0.02, 30, 100);
						camera.updateProjectionMatrix();
					}

					lastTouchDist = dist;
				} else {
					lastTouchDist = null;
				}
			}

			// 8. 渲染（把场景通过相机视角画出来）
			function animate() {
				requestAnimationFrame(animate);

				if (autoRotate) {
					// 直接旋转相机或控制对象
					// 方法1: 直接旋转相机的水平视角
					camera.rotation.y += 0.0015;

					// 方法2: 如果上面的方法有问题，可以使用下面的方式
					// controls.target.x = Math.sin(Date.now() * 0.001) * 5;
					// controls.target.z = Math.cos(Date.now() * 0.001) * 5;
				}

				controls.update();
				renderer.render(scene, camera);
			}
		</script>
	</body>

</html>
